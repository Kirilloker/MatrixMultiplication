@page
@{
    Layout = "_Layout";
    ViewData["Title"] = "Теория";
}

<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js">
</script>

<div class="card mt-3 shadow">
    <div class="card-header bg-success text-white">
        <h2>Теория умножения матриц</h2>
    </div>
    <div class="card-body">
        <p>
            <strong>Классическое (строчно-столбцовое) умножение матриц:</strong><br />
            Пусть дана матрица \(A\) размером \(n \times p\) и матрица \(B\)
            размером \(p \times m\). Тогда произведение \(C = A \times B\) будет
            размером \(n \times m\). Элемент \(c_{ij}\) вычисляется как:
            \[
            c_{ij} = \sum_{k=1}^{p} a_{ik} \cdot b_{kj}.
            \]
            Таким образом, для вычисления одной строки результирующей матрицы нам
            нужно перебрать соответствующую строку из \(A\) и столбец из \(B\).
        </p>
        <p>
            С точки зрения вычислительной сложности, классический алгоритм умножения
            занимает \(O(n \times p \times m)\) операций, где \(n\) — число строк
            в A, \(p\) — число столбцов в A (и строк в B), а \(m\) — число столбцов в B.
        </p>
        <hr />
        <p>
            <strong>Блочное умножение матриц (Block matrix multiplication):</strong><br />
            Вместо того, чтобы умножать отдельные элементы, можно разбить исходные
            матрицы на блоки меньшего размера. Затем каждый блок умножается
            «как маленькая подматрица», а результаты складываются между соответствующими
            блоками.
        </p>
        <p>
            При грамотном подборе размера блока достигается более эффективное использование
            кэш-памяти процессора, что на практике может сильно ускорять расчёты,
            особенно на больших матрицах. При этом асимптотическая сложность
            (при стандартном умножении) остаётся \(O(n \times p \times m)\),
            но постоянные факторы существенно уменьшаются.
        </p>
        <hr />
        <p>
            <strong>Другие методы:</strong><br />
            Существуют и более продвинутые алгоритмы умножения, например, алгоритм Штрассена,
            алгоритм Копперсмитта-Винограда и их модификации, позволяющие умножать
            матрицы быстрее, чем \(O(n^3)\). Однако они сложнее в реализации
            и имеют смысл лишь на очень больших данных и/или специальных архитектурах.
        </p>
        <p>
            В данном проекте мы сравниваем именно классическое и блочное умножение,
            чтобы наглядно увидеть разницу в производительности.
        </p>
    </div>
</div>
